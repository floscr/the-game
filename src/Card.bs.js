// Generated by BUCKLESCRIPT VERSION 3.1.4, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Random = require("bs-platform/lib/js/random.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var InvalidCard = Caml_exceptions.create("Card-ReasonmlTheGame.InvalidCard");

var NotEnoughCards = Caml_exceptions.create("Card-ReasonmlTheGame.NotEnoughCards");

function string_of_face(f) {
  switch (f) {
    case 0 : 
        return "Ace";
    case 1 : 
        return "Two";
    case 2 : 
        return "Three";
    case 3 : 
        return "Four";
    case 4 : 
        return "Five";
    case 5 : 
        return "Six";
    case 6 : 
        return "Seven";
    case 7 : 
        return "Eight";
    case 8 : 
        return "Nine";
    case 9 : 
        return "Ten";
    case 10 : 
        return "Jack";
    case 11 : 
        return "Queen";
    case 12 : 
        return "King";
    
  }
}

function string_of_suit(s) {
  switch (s) {
    case 0 : 
        return "Diamonds";
    case 1 : 
        return "Clubs";
    case 2 : 
        return "Hearts";
    case 3 : 
        return "Spades";
    
  }
}

function string_of_card(param) {
  return Curry._2(Printf.sprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* String_literal */Block.__(11, [
                          " of ",
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "%s of %s"
                ]), string_of_face(param[1]), string_of_suit(param[0]));
}

function int_of_face(f) {
  return f;
}

function face_from_int(n) {
  if (n > 12 || n < 0) {
    throw InvalidCard;
  } else {
    return n;
  }
}

function int_of_suit(s) {
  switch (s) {
    case 0 : 
        return 1;
    case 1 : 
        return 0;
    case 2 : 
        return 2;
    case 3 : 
        return 3;
    
  }
}

function suit_from_int(n) {
  if (n > 3 || n < 0) {
    throw InvalidCard;
  } else {
    switch (n) {
      case 0 : 
          return /* Clubs */1;
      case 1 : 
          return /* Diamonds */0;
      case 2 : 
          return /* Hearts */2;
      case 3 : 
          return /* Spades */3;
      
    }
  }
}

function pick_a_card(d) {
  return (function (param) {
      return List.nth(d, param);
    });
}

function any_card_int(d) {
  Random.self_init(/* () */0);
  return Random.$$int(List.length(d));
}

function any_card(d) {
  var param = any_card_int(d);
  return List.nth(d, param);
}

function take_a_card(d, x) {
  if (x < List.length(d)) {
    var _n = 0;
    var _left = /* [] */0;
    var _right = d;
    while(true) {
      var right = _right;
      var left = _left;
      var n = _n;
      if (x === n) {
        return /* tuple */[
                List.hd(right),
                Pervasives.$at(left, List.tl(right))
              ];
      } else {
        _right = List.tl(right);
        _left = Pervasives.$at(left, /* :: */[
              List.hd(right),
              /* [] */0
            ]);
        _n = n + 1 | 0;
        continue ;
      }
    };
  } else {
    throw InvalidCard;
  }
}

function take_x_cards(d, x) {
  var _c = /* [] */0;
  var _d$prime = d;
  var _y = x;
  while(true) {
    var y = _y;
    var d$prime = _d$prime;
    var c = _c;
    var match = take_a_card(d$prime, 0);
    var new_deck = match[1];
    var hand_000 = match[0];
    var hand = /* :: */[
      hand_000,
      c
    ];
    if ((y - 1 | 0) === 0) {
      return /* tuple */[
              hand,
              new_deck
            ];
    } else {
      _y = y - 1 | 0;
      _d$prime = new_deck;
      _c = hand;
      continue ;
    }
  };
}

function deck() {
  var _deck_so_far = /* [] */0;
  var _card_n = 0;
  while(true) {
    var card_n = _card_n;
    var deck_so_far = _deck_so_far;
    var suit_n = card_n / 13 | 0;
    var face_n = card_n % 13;
    if (card_n === 52 || suit_n > 3) {
      return deck_so_far;
    } else {
      _card_n = card_n + 1 | 0;
      _deck_so_far = /* :: */[
        /* tuple */[
          suit_from_int(suit_n),
          face_from_int(face_n)
        ],
        deck_so_far
      ];
      continue ;
    }
  };
}

function compare_faces(param, param$1) {
  return param[1] - param$1[1] | 0;
}

function compare_cards(param, param$1) {
  var suit_b = param$1[0];
  var suit_a = param[0];
  if (int_of_suit(suit_a) === int_of_suit(suit_b)) {
    return param[1] - param$1[1] | 0;
  } else {
    return int_of_suit(suit_a) - int_of_suit(suit_b) | 0;
  }
}

function sort_cards(param) {
  return List.sort(compare_cards, param);
}

function shuffle(d) {
  var _so_far = /* [] */0;
  var _remaining = d;
  while(true) {
    var remaining = _remaining;
    var so_far = _so_far;
    if (remaining) {
      var match = take_a_card(remaining, any_card_int(remaining));
      _remaining = match[1];
      _so_far = /* :: */[
        match[0],
        so_far
      ];
      continue ;
    } else {
      return so_far;
    }
  };
}

function hands_match(hand_a, hand_b) {
  if (List.length(hand_a) === List.length(hand_b)) {
    var _n = 0;
    while(true) {
      var n = _n;
      if (n === List.length(hand_a)) {
        return true;
      } else if (List.mem(List.nth(hand_a, n), hand_b)) {
        _n = n + 1 | 0;
        continue ;
      } else {
        return false;
      }
    };
  } else {
    return false;
  }
}

function string_of_hand(hand) {
  var _hand_str = "";
  var _left_in_hand = hand;
  while(true) {
    var left_in_hand = _left_in_hand;
    var hand_str = _hand_str;
    if (left_in_hand) {
      _left_in_hand = left_in_hand[1];
      _hand_str = Curry._2(Printf.sprintf(/* Format */[
                /* String */Block.__(2, [
                    /* No_padding */0,
                    /* String_literal */Block.__(11, [
                        "; ",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* End_of_format */0
                          ])
                      ])
                  ]),
                "%s; %s"
              ]), string_of_card(left_in_hand[0]), hand_str);
      continue ;
    } else {
      return Curry._1(Printf.sprintf(/* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ]),
                      "%s"
                    ]), hand_str);
    }
  };
}

exports.InvalidCard = InvalidCard;
exports.NotEnoughCards = NotEnoughCards;
exports.string_of_face = string_of_face;
exports.string_of_suit = string_of_suit;
exports.string_of_card = string_of_card;
exports.int_of_face = int_of_face;
exports.face_from_int = face_from_int;
exports.int_of_suit = int_of_suit;
exports.suit_from_int = suit_from_int;
exports.pick_a_card = pick_a_card;
exports.any_card_int = any_card_int;
exports.any_card = any_card;
exports.take_a_card = take_a_card;
exports.take_x_cards = take_x_cards;
exports.deck = deck;
exports.compare_faces = compare_faces;
exports.compare_cards = compare_cards;
exports.sort_cards = sort_cards;
exports.shuffle = shuffle;
exports.hands_match = hands_match;
exports.string_of_hand = string_of_hand;
/* No side effect */
